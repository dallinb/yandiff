#!/usr/bin/perl -w
##############################################################################
# Copyright (c) 2008-2009, League of Crafty Programmers Ltd <info@locp.co.uk>
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY LEAGUE OF CRAFTY PROGRAMMERS ''AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL LEAGUE OF CRAFTY PROGRAMMERS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
use Getopt::Long;
use IO::Handle;
use Nmap::Parser;
use Pod::Usage;
use strict;

# Find hosts that are in both the observed and baseline scans.  Compare the
# status of the host and the status of each of the individual ports.
sub show_changed_hosts {
	my ($format, $baseline, $observed, $ports) = @_;
	my $output = "\nChanged hosts:\n" if ($format eq 'text');
	my $portid;
	$output = "" if ($format eq 'xml');

	for my $baseline_ip ($baseline->get_ips()) {
		my $observed_host = $observed->get_host($baseline_ip);
		next if (!defined($observed_host));

		# To have reached here the host exists in both the baseline
		# and the observed scans.
		my $host = Host->new();
		$host->hostname($observed_host->hostname());
		$host->ip_addr($baseline_ip);
		$host->status($observed_host->status());
		my $host_has_changed = 0;
		my @changed_services = ();
		my @missing_services = ();
		my @new_services = ();
		my $baseline_host = $baseline->get_host($baseline_ip);
		$host_has_changed = 1
		    if ($observed_host->status() ne $baseline_host->status());

		# Check for new or changed TCP services
		my @observed_services = ();
		my @baseline_services = ();
		@baseline_services = $baseline_host->tcp_ports();

		if ($ports) {
			if ( $ports =~ m/o/i ) {
				push(@observed_services,
				    $observed_host->tcp_ports('open'));
			}

			if ( $ports =~ m/f/i ) {
				for $portid
				    ($observed_host->tcp_ports('filtered')) {
					push(@observed_services, $portid) if
					    ($observed_host->tcp_port_state(
					    $portid) !~ m/unfiltered/i );
				}
			}

			if ( $ports =~ m/c/i ) {
				push(@observed_services,
				    $observed_host->tcp_ports('closed'));
			}

			if ( $ports =~ m/x/i ) {
				push(@observed_services,
				    $observed_host->tcp_ports('unfiltered'));
			}
		} else {
			@observed_services = $observed_host->tcp_ports();
		}

		for $portid (@observed_services) {
			# new services
			my $s = $observed_host->tcp_service($portid);
			my $service = Service->new();
			$service->name($s->name());
			$service->portid($portid);
			$service->proto("tcp");
			$service->status(
			    $observed_host->tcp_port_state($portid));

			if (!grep {$_ eq $portid} @baseline_services) {
				$host_has_changed = 1;
				push @new_services, $service;
				next;
			}

			# must be a changed service
			my $service2 = Service->new();
			$service2->name($s->name());
			$service2->portid($portid);
			$service2->proto("tcp");
			$service2->status(
			    $baseline_host->tcp_port_state($portid));

			if ($service->compare($service2) != 0) {
				$host_has_changed = 1;
				push @changed_services, $service;
			}
		}

		# Check for missing TCP ports
		if (! $ports ) {
			for $portid (@baseline_services) {
				my $s = $baseline_host->tcp_service($portid);
				my $service = Service->new();
				$service->name($s->name());
				$service->portid($portid);
				$service->proto("tcp");
				$service->status(
				    $baseline_host->tcp_port_state($portid));

				if (!grep {$_ eq $portid}
				    @observed_services) {
					$host_has_changed = 1;
					push @missing_services, $service;
					next;
				}
			}
		}

		# Check for new or changed UDP services
		@observed_services = ();
		@baseline_services = ();
		@baseline_services = $baseline_host->udp_ports();

		if ($ports) {
			if ( $ports =~ m/o/i ) {
				push(@observed_services,
				    $observed_host->udp_ports('open'));
			}

			if ( $ports =~ m/f/i ) {
				for $portid (
				    $observed_host->udp_ports('filtered')) {
					push(@observed_services, $portid) if
					    ($observed_host->udp_port_state(
					    $portid) !~ m/unfiltered/i );
				}
			}

			if ( $ports =~ m/c/i ) {
				push(@observed_services,
				    $observed_host->udp_ports('closed'));
			}

			if ( $ports =~ m/x/i ) {
				push(@observed_services,
				    $observed_host->udp_ports('unfiltered'));
			}
		} else {
			@observed_services = $observed_host->udp_ports();
		}

		for $portid (@observed_services) {
			my $s = $observed_host->udp_service($portid);
			my $service = Service->new();
			$service->name($s->name());
			$service->portid($portid);
			$service->proto("udp");
			$service->status(
			    $observed_host->udp_port_state($portid));

			if (!grep {$_ eq $portid} @baseline_services) {
				$host_has_changed = 1;
				push @new_services, $service;
				next;
			}

			my $service2 = Service->new();
			$service2->name($s->name());
			$service2->portid($portid);
			$service2->proto("udp");
			$service2->status(
			    $baseline_host->udp_port_state($portid));

			if ($service->compare($service2) != 0) {
				$host_has_changed = 1;
				push @changed_services, $service;
			}
		}

		# Check for missing UDP ports
		if (! $ports ) {
			for $portid (@baseline_services) {
				my $s = $baseline_host->udp_service($portid);
				my $service = Service->new();
				$service->name($s->name());
				$service->portid($portid);
				$service->proto("udp");
				$service->status(
				    $baseline_host->udp_port_state($portid));

				if (!grep {$_ eq $portid}
				    @observed_services) {
					$host_has_changed = 1;
					push @missing_services, $service;
					next;
				}
			}
		}

		next if (!$host_has_changed);

		# To have reached here then a change has been detected in the
		# host between the scans.

		if ($format eq 'text') {
			$output .= "\t" . $host->to_string() . "\n";
			$output .= "\t\tNew Services:\n";

			for my $service (@new_services) {
				$output .= "\t\t\t" . $service->to_string()
				    . "\n";
			}

			$output .= "\t\tMissing Services:\n";

			for my $service (@missing_services) {
				$output .= "\t\t\t" . $service->to_string()
				    . "\n";
			}

			$output .= "\t\tChanged Services:\n";

			for my $service (@changed_services) {
				$output .= "\t\t\t" . $service->to_string()
				    . "\n";
			}
		} else {
			# XML output for differing hosts.
			$output .= "  " . $host->to_xml(0) . "\n";

			if (scalar(@new_services) == 0) {
				$output .= "   <new_services/>\n";
			} else {
				$output .= "   <new_services>\n";

				for my $service (@new_services) {
					$output .= "    "
					    . $service->to_xml()
					    . "\n";
				}

				$output .= "   </new_services>\n";
			}

			if (scalar(@missing_services) == 0) {
				$output .= "   <missing_services/>\n";
			} else {
				$output .= "   <missing_services>\n";

				for my $service (@missing_services) {
					$output .= "    "
					    . $service->to_xml()
					    . "\n";
				}

				$output .= "   </missing_services>\n";
			}

			if (scalar(@changed_services) == 0) {
				$output .= "   <changed_services/>\n";
			} else {
				$output .= "   <changed_services>\n";

				for my $service (@changed_services) {
					$output .= "    "
					    . $service->to_xml()
					    . "\n";
				}

				$output .= "   </changed_services>\n";
			}

			$output .= "  </host>\n";
		}
	}

	if ($format eq 'xml') {
		if ($output) {
			$output = " <changed>\n" . $output . " </changed>\n";
		} else {
			$output = " <changed/>\n";
		}
	}

	print $output;
}

# Find hosts that are defined in the baseline but are missing from the
# observed scan.
sub show_missing_hosts {
	my ($format, $baseline, $observed) = @_;
	my @hosts = ();

	for my $baseline_ip ($baseline->get_ips()) {
		my $observed_host = $observed->get_host($baseline_ip);

		if (!defined($observed_host)) {
			my $baseline_host = $baseline->get_host($baseline_ip);
			my $host = Host->new();
			$host->hostname($baseline_host->hostname());
			$host->ip_addr($baseline_ip);
			push @hosts, $host;
		}
	}

	my $output = '';
	$output = "\nMissing hosts:\n" if ($format eq 'text');
	$output = " <missing>\n" if (scalar(@hosts) != 0
	    && $format eq 'xml');
	$output = " <missing/>\n" if (scalar(@hosts) == 0
	    && $format eq 'xml');

	for my $host (@hosts) {
		$output .= "\t" . $host->to_string . "\n"
		    if ($format eq 'text');
		$output .= "  " . $host->to_xml(1) . "\n"
		    if ($format eq 'xml');
	}

	$output .= " </missing>\n"
	    if (scalar(@hosts) != 0 && $format eq 'xml');
	print $output;
}

# Find hosts that are defined in the baseline scan, but are missing from the
# observed scan.
sub show_new_hosts {
	my ($format, $baseline, $observed) = @_;
	my @hosts = ();

	for my $observed_ip ($observed->get_ips()) {
		my $baseline_host = $baseline->get_host($observed_ip);

		if (!defined($baseline_host)) {
			my $observed_host = $observed->get_host($observed_ip);
			my $host = Host->new();
			$host->hostname($observed_host->hostname());
			$host->ip_addr($observed_ip);
			$host->status($observed_host->status());

			for my $portid ($observed_host->tcp_ports()) {
				my $s = $observed_host->tcp_service($portid);
				my $service = Service->new();
				$service->name($s->name());
				$service->portid($portid);
				$service->proto("tcp");
				$service->status(
				    $observed_host->tcp_port_state($portid));
				$host->add_service($service);
			}

			for my $portid ($observed_host->udp_ports()) {
				my $s = $observed_host->udp_service($portid);
				my $service = Service->new();
				$service->name($s->name());
				$service->portid($portid);
				$service->proto("udp");
				$service->status(
				    $observed_host->udp_port_state($portid));
				$host->add_service($service);
			}

			push @hosts, $host;
		}
	}

	my $output = '';
	$output = "\nNew hosts:\n" if ($format eq 'text');
	$output = " <new>\n" if (scalar(@hosts) != 0 && $format eq 'xml');
	$output = " <new/>\n" if (scalar(@hosts) == 0 && $format eq 'xml');

	for my $host (@hosts) {
		if ($format eq 'text') {
			$output .= "\t" . $host->to_string . "\n";
		} else {
			$output .= "  " . $host->to_xml(0) . "\n";
		}

		for my $portid ($host->get_tcp_service_list()) {
			my $svc = $host->get_service($portid, "tcp");

			if ($format eq 'text') {
				$output .= "\t\t" . $svc->to_string() . "\n";
			} else {
				$output .= "   " . $svc->to_xml() . "\n";
			}
		}

		for my $portid ($host->get_udp_service_list()) {
			my $svc = $host->get_service($portid, "udp");

			if ($format eq 'text') {
				$output .= "\t\t" . $svc->to_string() . "\n";
			} else {
				$output .= "   " . $svc->to_xml() . "\n";
			}
		}

		$output .= "  </host>\n" if ($format eq 'xml');
	}

	$output .= " </new>\n"
	    if (scalar(@hosts) != 0 && $format eq 'xml');
	print $output;
}

##############################################################################
# Main processing starts here.
##############################################################################

# Declare and initialise variables.
my $baseline_file;
my ($c, $entry);
my $command_line;
my $format;
my $gen_stylesheet;
my $help;
my $man;
my $observed_file;
my $output_file;
my $output_hosts;
my $output_ports;
my $run_date;
my $show_version;
my $show_changed_hosts = 1;
my $show_missing_hosts = 1;
my $show_new_hosts = 1;
my $stylesheet;
my $xslt;

# OK so all the other variables are in lowercase and local.  The reason why
# version is specified differently is that that it is compatible with
# Module::Build therefore making distribution and installing easier.
my $VERSION = '0.6';

$run_date = localtime;

##############################################################################
# Command line parsing.
##############################################################################

$command_line = join(' ', @ARGV);

GetOptions(
	'baseline=s' => \$baseline_file,
	'format=s' => \$format,
	'gen-stylesheet=s' => \$gen_stylesheet,
	'help|?' => \$help,
	'man' => \$man,
	'observed|o=s' => \$observed_file,
	'output-file|of=s' => \$output_file,
	'output-hosts|os=s' => \$output_hosts,
	'output-ports|op=s' => \$output_ports,
	'stylesheet=s' => \$stylesheet,
	'version|V' => \$show_version
	) or pod2usage(1);

pod2usage(0) if $help;
pod2usage(-verbose => 2) if $man;

if ($show_version) {
	if ($baseline_file || $format || $gen_stylesheet || $help || $man ||
	    $observed_file || $output_ports || $stylesheet) {
		pod2usage(1);
	} else {
		print "Version: $VERSION\n";
		exit(0);
	}
}

if ($gen_stylesheet) {
	if ($baseline_file || $format || $help || $man ||
	    $observed_file || $output_ports || $show_version || $stylesheet) {
		pod2usage(1);
	} else {
		$xslt = new Stylesheet;
		$xslt->generate($gen_stylesheet);
		exit(0);
	}
}

$format = 'text' if (!$format);

if ($stylesheet && ! -e $stylesheet) {
	unless ($stylesheet =~ m/:\/\//i) {
		# To be here, a stylesheet has been specified that is not a
		# URL (i.e. it is a file) and the file doesn't currently
		# exist, so create it.
		$xslt = new Stylesheet;
		$xslt->generate($stylesheet);
	}
}

if ($output_hosts) {
	$show_changed_hosts = $show_missing_hosts = $show_new_hosts = 0;

	for (my $i = 0; $i < length($output_hosts); $i++) {
		$c = substr($output_hosts, $i, 1);
		if ($c eq "c") {
			$show_changed_hosts = 1;
		} elsif ($c eq "m") {
			$show_missing_hosts = 1;
		} elsif ($c eq "n") {
			$show_new_hosts = 1;
		} else {
			pod2usage(1);
		}
	}
}

if ($output_ports) {
	for (my $i = 0; $i < length($output_ports); $i++) {
		$c = substr($output_ports, $i, 1);
		if ($c eq 'o') {
			next;
		} elsif ($c eq 'f') {
			next;
		} elsif ($c eq 'c') {
			next;
		} elsif ($c eq 'x') {
			next;
		} else {
			pod2usage(1);
		}
	}
}

if ($format eq 'text' || $format eq 'xml') {
	;
} else {
	pod2usage(1);
}

##############################################################################
# Open and parse the files
##############################################################################
pod2usage(1) if !$baseline_file;
my $baseline = new Nmap::Parser;
$baseline->parsefile($baseline_file);
pod2usage(1) if !$observed_file;
my $observed = new Nmap::Parser;
$observed->parsefile($observed_file);

# Redirect the output if requested.  Obviously this must be called after
# all command line checks and usage messages.
if ($output_file) {
	open OUTPUT, '>', $output_file or die $!;
	STDOUT->fdopen(\*OUTPUT, 'w') or die $!;
}

# Do the report.

if ($format eq 'text') {
	print 'xndiff run ', $run_date, "\n",
	    'command line: ', $command_line, "\n",
	    'baseline: ', $baseline_file, "\n",
	    'observed: ', $observed_file, "\n";
} else {
	print '<?xml version="1.0" encoding="utf-8"?>',
	    "\n";
	print '<?xml-stylesheet type="text/xsl" href="',
	    $stylesheet,
	    '"?>',
	    "\n" if ($stylesheet);
	print "<xndiff rundate=\"$run_date\"",
	    ' version="', $VERSION, '"',
	    ' command_line="', $command_line, '">', "\n";
	print " <parameters>\n";
	my $session = $baseline->get_session();
	print "  <baseline>\n",
	    "   <file>$baseline_file</file>\n",
	    '   <scan_args>', $session->scan_args, "</scan_args>\n",
	    '   <nmap_version>', $session->nmap_version, "</nmap_version>\n",
	    '   <scan_start>', $session->start_str, "</scan_start>\n",
	    "  </baseline>\n";
	$session = $observed->get_session();
	print "  <observed>\n",
	    "   <file>$observed_file</file>\n",
	    '   <scan_args>', $session->scan_args, "</scan_args>\n",
	    '   <nmap_version>', $session->nmap_version, "</nmap_version>\n",
	    '   <scan_start>', $session->start_str, "</scan_start>\n",
	    "  </observed>\n";
	print " </parameters>\n";
}

show_new_hosts($format, $baseline, $observed) if $show_new_hosts;
show_missing_hosts($format, $baseline, $observed) if $show_missing_hosts;
show_changed_hosts($format, $baseline, $observed, $output_ports)
    if $show_changed_hosts;
print "</xndiff>\n" if ($format eq 'xml');

##############################################################################
# Package: Host
#
# This package is for use with xndiff and is for using an object representing
# a host.
#
# Example:
#
#	$host = Host->new();
#	$host->hostname("example");
#	$host->status("up");
#	$host->ip_addr("192.168.0.1");
#
#	...
#
#	$host->add_service($service);
##############################################################################
package Host;
use strict;

# Create a new instance of the Host object.
sub new {
	my $self = {};
	$self->{HOSTNAME} = undef;
	$self->{IP_ADDR} = undef;
	$self->{STATUS} = undef;
	$self->{SERVICES} = [];
	bless($self);
	return $self;
}

# Associate a Service object with this host.
sub add_service {
	my $self = shift;
	push @{ $self->{SERVICES} }, shift;
}

# A conveniance function for numeric sorting.
sub by_number_ascending
{
	$a <=> $b;
}

# Return a service that matches the associated portid and protocol.
#
# Example:
#
#	$service = $host->get_service(80, "tcp");
sub get_service {
	my $self = shift;
	my $portid = shift;
	my $proto = shift;
	my $null_service = ();

	for my $service (@{ $self->{SERVICES} }) {
		if ($portid eq $service->portid && $proto eq $service->proto) {
			return $service;
		}
	}

	return $null_service;
}

# Returns a sorted list of the portid's for the TCP services associated with
# the host.
sub get_tcp_service_list {
	my $self = shift;
	my @list = ();

	for my $service (@{ $self->{SERVICES} }) {
		push @list, $service->portid if ($service->proto eq "tcp");
	}

	return sort(by_number_ascending @list);
}

# Returns a sorted list of the portid's for the UDP services associated with
# the host.
sub get_udp_service_list {
	my $self = shift;
	my @list = ();

	for my $service (@{ $self->{SERVICES} }) {
		push @list, $service->portid if ($service->proto eq "udp");
	}

	return sort(by_number_ascending @list);
}

# Get or set the hostname
sub hostname {
	my $self = shift;
	$self->{HOSTNAME} = shift if (@_);
	return $self->{HOSTNAME};
}

# Get or set the IP address.
sub ip_addr {
	my $self = shift;
	$self->{IP_ADDR} = shift if (@_);
	return $self->{IP_ADDR};
}

# Get or set the status of the host.
sub status {
	my $self = shift;
	$self->{STATUS} = shift if (@_);
	return $self->{STATUS};
}

# Return the host details (not any associated ports) as a string.
sub to_string {
	my $self = shift;
	my $s = $self->{IP_ADDR} . ' (' . $self->{HOSTNAME} . ')';
	$s .= ' - ' . $self->{STATUS} if defined $self->{STATUS};
	return $s;
}

# Return the host details (not any associated ports) as xml.
sub to_xml {
	my $self = shift;
	my $close_fully = shift;
	my $s = "<host ip_addr=\"" . $self->{IP_ADDR}
	    . "\" hostname=\"" . $self->{HOSTNAME} . "\"";
	$s .= ' status="' . $self->{STATUS} . '"' if defined $self->{STATUS};
	my $close = ($close_fully) ? '/>' : '>';
	$s .= $close;
	return $s;
}
1;

##############################################################################
# Package: Service
#
# This package is for use with xndiff and is for using an object representing
# a TCP or UDP service.
#
# Example:
#
#	$service = Service->new();
#	$service->name("ssh");
#	$service->portid(22);
#	$service->proto("tcp");
#	$service->status("open");
#	$service->compare($another_service);
##############################################################################
package Service;
use strict;

# Create a new instance of the Service object.
sub new {
	my $self = {};
	$self->{NAME} = '';
	$self->{PORTID} = undef;
	$self->{PROTO} = undef;
	$self->{STATUS} = '';
	bless($self);
	return $self;
}

# Compare the current service with another Service instance.  Returns zero if
# the services are identical, non-zero otherwise.
sub compare {
	my $self = shift;
	my $service = shift;


	if (defined ($service->name)) {
		return 1 if (!defined ($self->{NAME}));
		return 1 if ($service->name ne $self->{NAME});
	} elsif (defined ($self->{NAME})) {
		return 1;
	}

	return 1 if ($service->status ne $self->{STATUS});
	return 0;
}

# Get or set the name of the service.
sub name {
	my $self = shift;
	$self->{NAME} = shift if (@_);
	return $self->{NAME};
}

# Get or set the portid of the service.
sub portid {
	my $self = shift;
	$self->{PORTID} = shift if (@_);
	return $self->{PORTID};
}

# Get or set the protocol of the service ("tcp" or "udp").
sub proto {
	my $self = shift;
	$self->{PROTO} = shift if (@_);
	return $self->{PROTO};
}

# Get or set the status of the service.
sub status {
	my $self = shift;
	$self->{STATUS} = shift if (@_);
	return $self->{STATUS};
}

# Return a string representation of the service.
sub to_string {
	my $self = shift;
	my $s = "$self->{PORTID}/";
	$s .= "$self->{PROTO}/";
	$s .= "$self->{STATUS}";
	$s .= " ($self->{NAME})" if ($self->{NAME});
	return $s;
}

# Return an XML representation of the service.
sub to_xml {
	my $self = shift;
	my $s = '<service portid="' . $self->{PORTID} . '"'
	    . ' proto="' . $self->{PROTO} . '"'
	    . ' status="' . $self->{STATUS} . '"';
	$s .= ' name="' . $self->{NAME} . '"' if ($self->{NAME});
	$s .= '/>';
	return $s;
}

1;

##############################################################################
# Package: Stylesheet
#
# This package is for use with xndiff and is for generating an XML
# stylesheet.
#
# Example:
#
#    $xslt = Service->new();
#    $xslt->generate(filename);
##############################################################################
package Stylesheet;
use strict;

# Create a new instance of the Stylesheet object.
sub new {
	my $self = {};
	$self->{FILENAME} = '';
	$self->{XSL_VERSION} = '1.2';
	bless($self);
	return $self;
}

# Write the stylesheet to the specified filename.
sub generate {
	my $self = shift;
	my $filename = shift;
	open OUTPUT, '>', $filename or die $!;
	print OUTPUT <<_EOF;
<?xml version="1.0" encoding="utf-8"?>
<!--
 Generated by the xndiff program.

 See http://code.google.com/p/xndiff for details.
-->

<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<!-- ............... Set the VERSION here ....................... -->
<xsl:variable name="xndiff_xsl_version">1.3</xsl:variable>
<!-- ............................................................ -->

<xsl:template match="xndiff">
<html>
<head>
<title>xndiff report</title>
<style type="text/css">
/* stylesheet print */
\@media print
{
 #menu { display:none; }

 h1 { font-size: 13pt; font-weight:bold; margin:4pt 0pt 0pt 0pt;
  padding:0; }

 h2 { font-size: 12pt; font-weight:bold; margin:3pt 0pt 0pt 0pt; padding:0; }

 h3 { font-size: 9pt; font-weight:bold; margin:1pt 0pt 0pt 20pt; padding:0; }

 p,ul { font-size: 9pt; margin:1pt 0pt 8pt 40pt; padding:0; text-align:left; }

 li { font-size: 9pt; margin:0; padding:0; text-align:left; }

 table { margin:1pt 0pt 8pt 40pt; border:0px; width:90% }

 td { border:0px; border-top:1px solid black; font-size: 9pt; }

 .head td { border:0px; font-weight:bold; font-size: 9pt; }
}

/* stylesheet screen */
\@media screen {
 body { margin: 0px; background-color: #FFFFFF; color: #000000;
  text-align: center; }

 #container { text-align:left; margin: 10px auto; width: 90%; }

 h1 { font-family: Verdana, Helvetica, sans-serif; font-weight:bold;
  font-size: 14pt; color: #000000; background-color:#87CEFA;
  margin:10px 0px 0px 0px; padding:5px 4px 5px 4px; width: 100%;
  border:1px solid black; text-align: left; }

 h2 { font-family: Verdana, Helvetica, sans-serif; font-weight:bold;
  font-size: 11pt; color: #000000; margin:30px 0px 0px 0px; padding:4px;
  width: 100%; border:1px solid black; background-color:#F0F8FF;
  text-align: left; }

 h2.green { color: #000000; background-color:#CCFFCC; border-color:#006400; }

 h2.red { color: #000000; background-color:#FFCCCC; border-color:#8B0000; }

 h2.orange { color: #000000; background-color:#FFDDBB; border-color:#8B0000; }
   
 h3 { font-family: Verdana, Helvetica, sans-serif; font-weight:bold;
  font-size: 10pt; color:#000000; background-color: #FFFFFF; width: 75%;
  text-align: left; }

 p { font-family: Verdana, Helvetica, sans-serif; font-size: 8pt;
  color:#000000; background-color: #FFFFFF; width: 75%; text-align: left; }

 p i { font-family: "Courier New", Courier, mono; font-size: 8pt;
  color:#000000; background-color: #CCCCCC; }

 ul { font-family: Verdana, Helvetica, sans-serif; font-size: 8pt;
  color:#000000; background-color: #FFFFFF; width: 75%; text-align: left; }

 a { font-family: Verdana, Helvetica, sans-serif; text-decoration: none;
  font-size: 8pt; color:#000000; font-weight:bold; background-color: #FFFFFF;
  color: #000000; }

 li a { font-family: Verdana, Helvetica, sans-serif; text-decoration: none;
  font-size: 10pt; color:#000000; font-weight:bold; background-color: #FFFFFF;
  color: #000000; }

 a:hover { text-decoration: underline; }

 a.red { color:#8B0000; }

 a.orange { color: orange; }

 a.green { color:#006400; }

 table { width: 80%; border:0px; color: #000000; background-color: #000000;
  margin:10px; }

 tr { vertical-align:top; font-family: Verdana, Helvetica, sans-serif;
  font-size: 8pt; color:#000000; background-color: #D1D1D1; }

 tr.head { background-color: #E1E1E1; color: #000000; font-weight:bold; }

 tr.open { background-color: #CCFFCC; color: #000000; }

 tr.filtered { background-color: #FFDDBB; color: #000000; }

 tr.closed { background-color: #FFAFAF; color: #000000; }

 td { padding:2px; }

 .status { display:none; }

 #menu li { display: inline; margin: 0; padding: 0; list-style-type: none; }
}
</style>
</head>
<body>
 <h1>Xndiff</h1>

 <h2>Host Summary</h2>

 <xsl:if test="new">
  <p><b>New</b>:
  <xsl:for-each select="new">
   <xsl:apply-templates select="host"/>
  </xsl:for-each>
  </p>
 </xsl:if>

 <xsl:if test="missing">
  <p><b>Missing</b>:
  <xsl:for-each select="missing">
   <xsl:apply-templates select="host"/>
  </xsl:for-each>
  </p>
 </xsl:if>

 <xsl:if test="changed">
  <p><b>Changed</b>:
  <xsl:for-each select="changed">
   <xsl:apply-templates select="host"/>
  </xsl:for-each>
  </p>
 </xsl:if>

 <h2>Run Parameters</h2>

 <table border="1">
  <caption><h3>Xndiff Information</h3></caption>
  <tr>
   <td>Run Date</td>
   <td><xsl:value-of select="\@rundate"/></td>
  </tr>
  <tr>
   <td>Version</td>
   <td><xsl:value-of select="\@version"/></td>
  </tr>
  <tr>
   <td>Command Arguments</td>
   <td><i><xsl:value-of select="\@command_line"/></i></td>
  </tr>
 </table>

 <table border="1">
  <caption><h3>Baseline Information</h3></caption>
  <tr>
   <td>Run Date</td>
   <td><xsl:value-of select="parameters/baseline/scan_start"/></td>
  </tr>
  <tr>
   <td>Nmap Version</td>
   <td><xsl:value-of select="parameters/baseline/nmap_version"/></td>
  </tr>
  <tr>
   <td>Scan Arguments</td>
   <td><i><xsl:value-of select="parameters/baseline/scan_args"/></i></td>
  </tr>
 </table>

 <table border="1">
  <caption><h3>Observed Information</h3></caption>
  <tr>
   <td>Run Date</td>
   <td><xsl:value-of select="parameters/observed/scan_start"/></td>
  </tr>
  <tr>
   <td>Nmap Version</td>
   <td><xsl:value-of select="parameters/observed/nmap_version"/></td>
  </tr>
  <tr>
   <td>Scan Arguments</td>
   <td><i><xsl:value-of select="parameters/observed/scan_args"/></i></td>
  </tr>
 </table>

 <xsl:if test="new">
  <h2>New</h2>

  <xsl:for-each select="new/host">
   <xsl:element name="a">
    <xsl:attribute name="name">
     <xsl:value-of select="translate(\@ip_addr, '.', '_') " />
    </xsl:attribute>
   </xsl:element>

   <xsl:choose>
    <xsl:when test="\@status = 'up'">
     <h2 class="green">
      <xsl:value-of select="\@ip_addr"/>/<xsl:value-of select="\@hostname"/>
      (<xsl:value-of select="\@status"/>)
     </h2>
    </xsl:when>
    <xsl:otherwise>
     <h2 class="red">
      <xsl:value-of select="\@ip_addr"/>/<xsl:value-of select="\@hostname"/>
      (<xsl:value-of select="\@status"/>)
     </h2>
    </xsl:otherwise>
   </xsl:choose>

   <table border="1">
    <tr>
     <th>Port</th>
     <th>Protocol</th>
     <th>Status</th>
     <th>Name</th>
    </tr>

   <xsl:apply-templates select="service"/>

   </table>
  </xsl:for-each>

 </xsl:if>

 <xsl:if test="missing">
  <h2>Missing</h2>
  <ul>

  <xsl:for-each select="missing/host">
   <xsl:element name="a">
    <xsl:attribute name="name">
     <xsl:value-of select="translate(\@ip_addr, '.', '_') " />
    </xsl:attribute>
   </xsl:element>
   <li><b><xsl:value-of select="\@ip_addr"/>/<xsl:value-of
    select="\@hostname"/>
   </b></li>
  </xsl:for-each>
  </ul>
 </xsl:if>

 <xsl:if test="changed">
  <h2>Changed</h2>

  <xsl:for-each select="changed/host">
   <xsl:element name="a">
    <xsl:attribute name="name">
     <xsl:value-of select="translate(\@ip_addr, '.', '_') " />
    </xsl:attribute>
   </xsl:element>
   <xsl:choose>
    <xsl:when test="\@status = 'up'">
     <h2 class="green">
      <xsl:value-of select="\@ip_addr"/>/<xsl:value-of select="\@hostname"/>
      (<xsl:value-of select="\@status"/>)
     </h2>
    </xsl:when>
    <xsl:otherwise>
     <h2 class="red">
      <xsl:value-of select="\@ip_addr"/>/<xsl:value-of select="\@hostname"/>
      (<xsl:value-of select="\@status"/>)
     </h2>
    </xsl:otherwise>
   </xsl:choose>

   <table border="1">
    <tr>
     <th>Change Type</th>
     <th>Port</th>
     <th>Protocol</th>
     <th>Status</th>
     <th>Name</th>
    </tr>

    <xsl:for-each select="new_services">
     <xsl:apply-templates select="service"/>
    </xsl:for-each>

    <xsl:for-each select="missing_services">
     <xsl:apply-templates select="service"/>
    </xsl:for-each>

    <xsl:for-each select="changed_services">
     <xsl:apply-templates select="service"/>
    </xsl:for-each>
   </table>
  </xsl:for-each>
 </xsl:if>

 <sub>
  Ndiff stylesheet version: <xsl:value-of select="\$xndiff_xsl_version" />
  &lt;<a href = 
  "http://code.google.com/p/xndiff">http://code.google.com/p/xndiff</a>&gt;
 </sub>
</body>
</html>
</xsl:template>

<xsl:template match="host">
   &lt;<xsl:element name="a">
   <xsl:if test="name(parent::node()) = 'new'">
    <xsl:attribute name="class">green</xsl:attribute>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'missing'">
    <xsl:attribute name="class">red</xsl:attribute>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'changed'">
    <xsl:attribute name="class">orange</xsl:attribute>
   </xsl:if>
   <xsl:attribute name="href">
    #<xsl:value-of select="translate(\@ip_addr, '.', '_') "/>
   </xsl:attribute>
    <xsl:value-of select="\@ip_addr"/><xsl:text> / </xsl:text><xsl:value-of
    select="\@hostname"/>
   </xsl:element>&gt;
</xsl:template>

<xsl:template match="service">
<xsl:choose>
 <xsl:when test="\@status = 'open'">
  <tr class="open">
   <xsl:if test="name(parent::node()) = 'new_services'">
    <td>New</td>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'missing_services'">
    <td>Missing</td>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'changed_services'">
    <td>Changed</td>
   </xsl:if>
   <td><xsl:value-of select="\@portid"/></td>
   <td><xsl:value-of select="\@proto"/></td>
   <td><xsl:value-of select="\@status"/></td>
   <td><xsl:value-of select="\@name"/></td>
  </tr>
 </xsl:when>
 <xsl:when test="\@status = 'closed'">
  <tr class="closed">
   <xsl:if test="name(parent::node()) = 'new_services'">
    <td>New</td>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'missing_services'">
    <td>Missing</td>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'changed_services'">
    <td>Changed</td>
   </xsl:if>
   <td><xsl:value-of select="\@portid"/></td>
   <td><xsl:value-of select="\@proto"/></td>
   <td><xsl:value-of select="\@status"/></td>
   <td><xsl:value-of select="\@name"/></td>
  </tr>
 </xsl:when>
 <xsl:when test="\@status = 'filtered'">
  <tr class="filtered">
   <xsl:if test="name(parent::node()) = 'new_services'">
    <td>New</td>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'missing_services'">
    <td>Missing</td>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'changed_services'">
    <td>Changed</td>
   </xsl:if>
   <td><xsl:value-of select="\@portid"/></td>
   <td><xsl:value-of select="\@proto"/></td>
   <td><xsl:value-of select="\@status"/></td>
   <td><xsl:value-of select="\@name"/></td>
  </tr>
 </xsl:when>
 <xsl:otherwise>
  <tr>
   <xsl:if test="name(parent::node()) = 'new_services'">
    <td>New</td>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'missing_services'">
    <td>Missing</td>
   </xsl:if>
   <xsl:if test="name(parent::node()) = 'changed_services'">
    <td>Changed</td>
   </xsl:if>
   <td><xsl:value-of select="\@portid"/></td>
   <td><xsl:value-of select="\@proto"/></td>
   <td><xsl:value-of select="\@status"/></td>
   <td><xsl:value-of select="\@name"/></td>
  </tr>
 </xsl:otherwise>
</xsl:choose>
</xsl:template>
</xsl:stylesheet>
_EOF
	close(OUTPUT);
}
1;
__END__

=head1 NAME

xndiff - find differences between two nmap network scans

=head1 SYNOPSIS

xndiff
[-f, --format <text | xml>]
[-of, --output-file file]
[-oh, --output-hosts <nmc>]
[-op, --output-ports <ofcx>]
[-s, --stylesheet <file | URL>]
--baseline file
--observed file

xndiff --gen-stylesheet file

xndiff --help | -?

xndiff --man

xndiff --version

=head1 OPTIONS

=over 8

=item B<-b> file

=item B<--baseline> file

Specifies the nmap results to use as the baseline for the comparison.

=item B<-f> <text | xml>

=item B<--format> <text | xml>

Specifies the output format (text is the default).

=item B<-g> file

=item B<--gen-stylesheet> file

Generate an XML stylesheet (XSLT) suitable for use with the --stylesheet
option.

=item B<-h>

=item B<--help>

Print a brief help message and exit.

=item B<-m>

=item B<--man>

Print the manual page and exit.

=item B<-o> file

=item B<--observed> file

Specifies the nmap results to use as the "observed results" for the
comparison.

=item B<-of> file

=item B<--output-file> file

Send the output to the specified file.

=item B<-oh> <nmc>

=item B<--output-hosts> <nmc>

Specifies which types of hosts to display.  Any combination of n, m, or c may
be specified, as follows:

n = new hosts in the "observed" scan.

m = missing hosts in the "observed" scan.

c = changed hosts in the "observed" scan.

The default is to show new, missing and changed hosts.

=item B<-op> <ofcx>

=item B<--output-ports> <ofcx>

Specifies which ports to check when outputting changed hosts. Open, filtered
or closed ports.  Any combination of [ofcx] may be specified, as follows:

o = open ports in the "observed" scan.

f = filtered ports in the "observed" scan.

c = closed ports in the "observed" scan.

x = unfiltered ports in the "observed" scan

The default is to show all ports.

=item B<-s> <file | URL>

=item B<--stylesheet> <file | URL>

Specifies the location of an XML stylesheet to be referred to in any XML
output.  If the stylesheet specified is not a URL and is found to be a
non-existent file then it will be generated.  A suitable stylesheet can also
be generated using the --gen-stylesheet option.

=item B<-V>

=item B<--version>

Print the version and exit.

=back

=head1 DESCRIPTION

B<xndiff> allows a network administrator or other interested party to easily
monitor one or more networks for changes in port states and running
services.  It achieves this by comparing the results of two nmap scans,
one designated the "baseline", the other "observation".

Both baseline and observation are stored in files generated via nmap's
-oX switch for XML output.

=head1 EXAMPLES

To generate a report to screen:

=over 8

xndiff --baseline baseline.xml --observed observed.xml

=back

To generate a stylesheet to file:

=over 8

xndiff --gen-stylesheet xndiff.xsl

=back

To generate a report to an XML file and using the stylesheet generated in the
previous example:

=over 8

xndiff --baseline baseline.xml --observed observed.xml \
	--format xml --output-file report.xml

=back

=head1 HISTORY

Xndiff is loosely based on ndiff written by James Levine, except
where ndiff used "grepable" output from nmap, xndiff reads XML output using
Nmap::Parser.

=head1 AUTHORS

The Xndiff project at http://code.google.com/p/xndiff

=head1 BUGS

The project members graciously accept that there may be bugs.  If there are
any found, please report them at the link below or browse the issues reported
to see if a fix is either available or in progress.

http://code.google.com/p/xndiff/issues

=cut
